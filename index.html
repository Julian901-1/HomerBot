/*** –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –°–ï–†–í–ï–†–ù–ê–Ø –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø - Google Apps Script
* –í–µ—Ä—Å–∏—è: 3.2 - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–æ–≤
*/
const SHEET_ID = '1eG_c2RcYcZs6jkJIPi8x4QXJBTBKTf2FwA33Ct7KxHg'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à ID —Ç–∞–±–ª–∏—Ü—ã
const SHEET_NAME = 'HomerBot'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –∏–º—è –≤–∞—à–µ–≥–æ –ª–∏—Å—Ç–∞
const BOT_TOKEN = '7631840452:AAH4O93qQ6J914x5FhPTQX7YhJC3bTiJ_XA'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ç–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞
const ADMIN_CHAT_ID = '487525838'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à Chat ID

// === –û–ë–†–ê–ë–û–¢–ö–ê GET –ó–ê–ü–†–û–°–û–í ===
function doGet(e) {
  try {
    Logger.log('=== IMPROVED GET REQUEST ===');
    Logger.log('Timestamp: ' + new Date().toISOString());
    Logger.log('Parameters: ' + JSON.stringify(e.parameter || {}));

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    if (!e.parameter) {
      return handleJsonpResponse({ error: 'No parameters provided', usage: 'Add ?action=test to URL', timestamp: new Date().toISOString() }, e.parameter);
    }

    const action = e.parameter.action;
    const isJsonp = !!e.parameter.callback;
    Logger.log('Action: "' + action + '", JSONP: ' + isJsonp);

    let result;

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π
    switch (action) {
      case 'getBalance':
        result = handleGetBalance(e.parameter);
        break;
      case 'updateBalance':
        result = handleUpdateBalance(e.parameter);
        break;
      case 'getAllUsers':
        result = handleGetAllUsers();
        break;
      case 'sendNotification':
        result = handleNotificationRequest(e.parameter);
        break;
      case 'cancelPayment':
        result = handleCancelPayment(e.parameter);
        break;
      case 'checkPayment':
        result = handleCheckPayment(e.parameter);
        break;
      case 'getWebhookInfo':
        result = getWebhookInfo();
        break;
      case 'setupWebhook':
        result = handleWebhookSetup();
        break;
      case 'test':
        result = handleTestRequest();
        break;
      case 'imagePixelSync': // –ù–æ–≤—ã–π action –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ Image Pixel
        return handleImagePixelSync(e.parameter); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é, –Ω–µ —á–µ—Ä–µ–∑ JSONP
        break;
      default:
        result = { error: 'Unknown action: ' + action, availableActions: ['getBalance', 'updateBalance', 'getAllUsers', 'sendNotification', 'cancelPayment', 'checkPayment', 'test', 'getWebhookInfo', 'setupWebhook', 'imagePixelSync'] };
    }

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π JSONP
    return handleJsonpResponse(result, e.parameter);

  } catch (error) {
    Logger.log('‚ùå Error in doGet: ' + error.toString());
    Logger.log('Stack: ' + error.stack);
    const errorResult = { error: error.toString(), stack: error.stack, timestamp: new Date().toISOString() };
    // –í–ê–ñ–ù–û: –ü—Ä–∏ –æ—à–∏–±–∫–µ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ, –≤—ã–∑—ã–≤–∞–µ–º handleJsonpResponse –Ω–∞–ø—Ä—è–º—É—é, –±–µ–∑ —Ü–µ–ø–æ—á–∫–∏
    return ContentService.createTextOutput(JSON.stringify(errorResult, null, 2))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// === –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê JSONP –û–¢–í–ï–¢–û–í ===
// –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –±—ã–ª–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–∞ –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –æ—à–∏–±–∫–∏ setHeaders
function handleJsonpResponse(data, parameters) {
  try {
    const callback = parameters ? parameters.callback : null;

    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    const responseData = {
      ...data,
      _meta: {
        timestamp: new Date().toISOString(),
        method: callback ? 'JSONP' : 'JSON',
        version: '3.2-fixed'
      }
    };

    if (callback) {
      // JSONP –æ—Ç–≤–µ—Ç –¥–ª—è –æ–±—Ö–æ–¥–∞ CORS
      const jsonpResponse = callback + '(' + JSON.stringify(responseData) + ');';
      Logger.log('üì§ Sending JSONP response to callback: ' + callback);
      // –°–æ–∑–¥–∞–µ–º –æ—Ç–≤–µ—Ç
      const output = ContentService.createTextOutput(jsonpResponse);
      output.setMimeType(ContentService.MimeType.JAVASCRIPT);
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –û–¢–î–ï–õ–¨–ù–û
      output.setHeaders({
        'Content-Type': 'application/javascript; charset=utf-8',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      });
      return output;
    } else {
      // –û–±—ã—á–Ω—ã–π JSON –æ—Ç–≤–µ—Ç
      Logger.log('üì§ Sending JSON response');
      // –°–æ–∑–¥–∞–µ–º –æ—Ç–≤–µ—Ç
      const output = ContentService.createTextOutput(JSON.stringify(responseData, null, 2));
      output.setMimeType(ContentService.MimeType.JSON);
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –û–¢–î–ï–õ–¨–ù–û
      output.setHeaders({
        'Content-Type': 'application/json; charset=utf-8',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      });
      return output;
    }
  } catch (error) {
    Logger.log('‚ùå CRITICAL Error in handleJsonpResponse: ' + error.toString());
    // –í —Å–ª—É—á–∞–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏ –≤ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π JSON
    const criticalError = { error: 'Critical server error in response formatter', details: error.toString(), timestamp: new Date().toISOString() };
    const errorOutput = ContentService.createTextOutput(JSON.stringify(criticalError, null, 2));
    errorOutput.setMimeType(ContentService.MimeType.JSON);
    errorOutput.setHeaders({
      'Content-Type': 'application/json; charset=utf-8',
      'Access-Control-Allow-Origin': '*'
    });
    return errorOutput;
  }
}


// === –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê Image Pixel –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–ò ===
function handleImagePixelSync(params) {
  try {
    Logger.log('üñºÔ∏è Handling Image Pixel Sync Request');
    Logger.log('Parameters: ' + JSON.stringify(params));

    // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö, –Ω–∞–ø—Ä–∏–º–µ—Ä, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞
    if (params.username) {
        const updateResult = handleUpdateBalance(params); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ª–æ–≥–∏–∫—É
        Logger.log('Image Pixel Sync Update Result: ' + JSON.stringify(updateResult));
    } else {
         Logger.log('Image Pixel Sync: No username provided for update');
    }

    // –°–æ–∑–¥–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ 1x1 GIF (base64)
    const transparentGif = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // 1x1 transparent GIF

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    const response = ContentService.createTextOutput(Utilities.base64Decode(transparentGif, Utilities.Charset.UTF_8));
    response.setMimeType(ContentService.MimeType.IMAGE);
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –û–¢–î–ï–õ–¨–ù–û
    response.setHeaders({
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0',
      'Access-Control-Allow-Origin': '*'
    });
    Logger.log('üì§ Sending 1x1 Transparent GIF for Image Pixel Sync');
    return response;

  } catch (error) {
    Logger.log('‚ùå Error in handleImagePixelSync: ' + error.toString());
    // –î–∞–∂–µ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –º—ã –¥–æ–ª–∂–Ω—ã –≤–µ—Ä–Ω—É—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    const transparentGif = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    const errorResponse = ContentService.createTextOutput(Utilities.base64Decode(transparentGif, Utilities.Charset.UTF_8));
    errorResponse.setMimeType(ContentService.MimeType.IMAGE);
    errorResponse.setHeaders({
      'Content-Type': 'image/gif',
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
    return errorResponse;
  }
}

// === –û–ë–†–ê–ë–û–¢–ö–ê –ü–û–õ–£–ß–ï–ù–ò–Ø –ë–ê–õ–ê–ù–°–ê ===
function handleGetBalance(params) {
  try {
    const username = params.username;
    if (!username) {
      return { error: 'Username is required' };
    }

    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
    const data = sheet.getDataRange().getValues();

    const searchUsername = username.startsWith('@') ? username.substring(1) : username;
    let userRowIndex = -1;

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === username || data[i][0] === searchUsername || data[i][0] === '@' + searchUsername) {
        userRowIndex = i + 1;
        break;
      }
    }

    if (userRowIndex === -1) {
      return { success: false, message: 'User not found', username: username };
    }

    const userData = data[userRowIndex - 1];
    const timestamp = new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' });

    return {
      success: true,
      username: userData[0],
      strategy: userData[1] || 'standard',
      balance: parseFloat(userData[2]) || 0,
      timestamp: timestamp,
      action: 'getBalance'
    };

  } catch (error) {
    Logger.log('‚ùå Error in handleGetBalance: ' + error.toString());
    return { success: false, error: error.toString(), action: 'getBalance' };
  }
}

// === –û–ë–†–ê–ë–û–¢–ö–ê –û–ë–ù–û–í–õ–ï–ù–ò–Ø –ë–ê–õ–ê–ù–°–ê ===
function handleUpdateBalance(params) {
  try {
    const username = params.username;
    const newBalance = parseFloat(params.balance);
    const strategy = params.strategy || 'standard';

    if (!username) {
      return { error: 'Username is required' };
    }
    if (isNaN(newBalance)) {
      return { error: 'Invalid balance value' };
    }

    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
    const data = sheet.getDataRange().getValues();

    const searchUsername = username.startsWith('@') ? username.substring(1) : username;
    let userRowIndex = -1;

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === username || data[i][0] === searchUsername || data[i][0] === '@' + searchUsername) {
        userRowIndex = i + 1;
        break;
      }
    }

    const timestamp = new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' });

    if (userRowIndex === -1) {
      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const newRow = [username, strategy, newBalance, timestamp];
      sheet.appendRow(newRow);
      Logger.log('‚úÖ New user created: ' + username);
      return {
        success: true,
        message: 'New user created',
        username: username,
        strategy: strategy,
        balance: newBalance,
        timestamp: timestamp
      };
    } else {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      sheet.getRange(userRowIndex, 2).setValue(strategy);
      sheet.getRange(userRowIndex, 3).setValue(newBalance);
      sheet.getRange(userRowIndex, 4).setValue(timestamp);
      Logger.log('‚úÖ User balance updated: ' + username + ' to ' + newBalance);
      return {
        success: true,
        message: 'User balance updated',
        username: username,
        strategy: strategy,
        balance: newBalance,
        timestamp: timestamp
      };
    }

  } catch (error) {
    Logger.log('‚ùå Error in handleUpdateBalance: ' + error.toString());
    return { success: false, error: error.toString(), action: 'updateBalance' };
  }
}

// === –û–ë–†–ê–ë–û–¢–ö–ê –ü–û–õ–£–ß–ï–ù–ò–Ø –í–°–ï–• –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô ===
function handleGetAllUsers() {
  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
    const data = sheet.getDataRange().getValues();
    const users = [];
    for (let i = 1; i < data.length; i++) {
      if (data[i][0]) {
        users.push({
          username: data[i][0],
          strategy: data[i][1] || 'standard',
          balance: parseFloat(data[i][2]) || 0
        });
      }
    }
    Logger.log('‚úÖ Retrieved ' + users.length + ' users');
    return { success: true, users: users, count: users.length };
  } catch (error) {
    Logger.log('‚ùå Error in handleGetAllUsers: ' + error.toString());
    return { success: false, error: error.toString(), action: 'getAllUsers' };
  }
}

// === –û–°–ù–û–í–ù–ê–Ø –õ–û–ì–ò–ö–ê –û–¢–ü–†–ê–í–ö–ò –£–í–ï–î–û–ú–õ–ï–ù–ò–ô –í TELEGRAM ===
// –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –±—ã–ª–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞, —Ç–∞–∫ –∫–∞–∫ –Ω–∞ –Ω–µ–µ —Å—Å—ã–ª–∞–ª–∏—Å—å, –Ω–æ –æ–Ω–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞–ª–∞
function handleNotification(data) {
  try {
    const chatId = ADMIN_CHAT_ID;
    const message = data.message || `üîî Notification\nType: ${data.type}\nUser: ${data.userId}\nAmount: ${data.amount}\nTransaction ID: ${data.transactionId}`;

    const payload = {
      method: 'sendMessage',
      chat_id: String(chatId),
      text: message,
      parse_mode: 'HTML'
    };

    // –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è/–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –¥–ª—è –¥–µ–ø–æ–∑–∏—Ç–æ–≤
    if (data.type === 'deposit') {
      payload.reply_markup = JSON.stringify({
        inline_keyboard: [
          [
            { text: '‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', callback_data: `confirm_${data.transactionId}` },
            { text: '‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å', callback_data: `reject_${data.transactionId}` }
          ]
        ]
      });
    }

    const response = UrlFetchApp.fetch(`https://api.telegram.org/bot${BOT_TOKEN}/`, {
      method: 'POST',
      payload: payload,
      muteHttpExceptions: true
    });

    const result = response.getResponseCode() === 200 ? JSON.parse(response.getContentText()) : null;

    if (result && result.ok) {
      Logger.log('‚úÖ Telegram notification sent successfully, message_id: ' + result.result.message_id);
      return ContentService.createTextOutput(JSON.stringify({ success: true, messageId: result.result.message_id, telegramResponse: result }, null, 2))
        .setMimeType(ContentService.MimeType.JSON);
    } else {
      Logger.log('‚ùå Failed to send Telegram notification: ' + response.getContentText());
      return ContentService.createTextOutput(JSON.stringify({ success: false, error: 'Telegram API error', details: response.getContentText() }, null, 2))
        .setMimeType(ContentService.MimeType.JSON);
    }

  } catch (error) {
    Logger.log('‚ùå Error in handleNotification: ' + error.toString());
    return ContentService.createTextOutput(JSON.stringify({ success: false, error: error.toString() }, null, 2))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// === –û–ë–†–ê–ë–û–¢–ö–ê –û–¢–ü–†–ê–í–ö–ò –£–í–ï–î–û–ú–õ–ï–ù–ò–ô (WRAPPER) ===
function handleNotificationRequest(params) {
  try {
    const notificationData = {
      type: params.type,
      userId: params.userId,
      amount: parseFloat(params.amount || 0),
      transactionId: params.transactionId,
      message: params.message,
      strategy: params.strategy,
      phone: params.phone,
      commission: parseFloat(params.commission || 0),
      finalAmount: parseFloat(params.finalAmount || 0)
    };

    Logger.log('Processing notification request: ' + JSON.stringify(notificationData));
    // –í—ã–∑—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –æ–±—Ä–∞–±–æ—Ç–∫–∏
    return handleNotification(notificationData);

  } catch (error) {
    Logger.log('‚ùå Error in handleNotificationRequest: ' + error.toString());
    return ContentService.createTextOutput(JSON.stringify({ success: false, error: error.toString() }, null, 2))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// === –û–ë–†–ê–ë–û–¢–ö–ê –û–¢–ú–ï–ù–´ –ü–õ–ê–¢–ï–ñ–ê ===
function handleCancelPayment(params) {
  try {
    const transactionId = params.transactionId;
    if (!transactionId) {
      return { error: 'Transaction ID is required' };
    }

    Logger.log('üö´ Payment cancelled for transaction: ' + transactionId);

    return { success: true, message: 'Payment cancelled', transactionId: transactionId };

  } catch (error) {
    Logger.log('‚ùå Error in handleCancelPayment: ' + error.toString());
    return { success: false, error: error.toString(), action: 'cancelPayment' };
  }
}

// === –•–†–ê–ù–ò–õ–ò–©–ï –°–¢–ê–¢–£–°–û–í –ü–õ–ê–¢–ï–ñ–ï–ô ===
const paymentStatuses = {};

// === –û–ë–†–ê–ë–û–¢–ö–ê –ü–†–û–í–ï–†–ö–ò –°–¢–ê–¢–£–°–ê –ü–õ–ê–¢–ï–ñ–ê ===
function handleCheckPayment(params) {
  try {
    const transactionId = params.transactionId;
    if (!transactionId) {
      return { error: 'Transaction ID is required' };
    }

    const status = paymentStatuses[transactionId] || { confirmed: false };
    Logger.log('Payment status check - ID: ' + transactionId + ', Status: ' + JSON.stringify(status));
    return status;

  } catch (error) {
    Logger.log('‚ùå Error in handleCheckPayment: ' + error.toString());
    return { success: false, error: error.toString(), action: 'checkPayment' };
  }
}

// === –û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–°–¢–û–í–û–ì–û –ó–ê–ü–†–û–°–ê ===
function handleTestRequest() {
  const testResult = {
    success: true,
    message: 'Google Apps Script is working perfectly!',
    timestamp: new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' }),
    version: '3.2-fixed',
    server: 'Google Apps Script',
    methods: ['JSONP', 'Image Pixel'],
    capabilities: ['Balance Sync', 'User Management', 'Payment Processing'],
    sheetId: SHEET_ID
  };
  Logger.log('‚úÖ Test request successful');
  return testResult;
}

// === –§–£–ù–ö–¶–ò–ò TELEGRAM WEBHOOK ===
function setupTelegramWebhook() {
  try {
    const url = ScriptApp.getService().getUrl();
    const response = UrlFetchApp.fetch(`https://api.telegram.org/bot${BOT_TOKEN}/setWebhook?url=${encodeURIComponent(url)}`, {
      method: 'POST',
      muteHttpExceptions: true
    });
    const result = JSON.parse(response.getContentText());
    Logger.log('Webhook setup result: ' + JSON.stringify(result));
    return result;
  } catch (error) {
    Logger.log('‚ùå Error setting up webhook: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function getWebhookInfo() {
  try {
    const response = UrlFetchApp.fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getWebhookInfo`, {
      method: 'GET',
      muteHttpExceptions: true
    });
    return JSON.parse(response.getContentText());
  } catch (error) {
    Logger.log('‚ùå Error getting webhook info: ' + error.toString());
    return { error: error.toString() };
  }
}

function handleWebhookSetup() {
  try {
    Logger.log('Setting up webhook via GET request');
    const webhookResult = setupTelegramWebhook();
    if (webhookResult && webhookResult.ok) {
      return {
        success: true,
        message: 'Webhook setup successful!',
        webhookUrl: ScriptApp.getService().getUrl(),
        telegramResponse: webhookResult
      };
    } else {
      return {
        success: false,
        message: 'Webhook setup failed',
        error: webhookResult ? webhookResult.description : 'Unknown error',
        telegramResponse: webhookResult
      };
    }
  } catch (error) {
    Logger.log('‚ùå Error in handleWebhookSetup: ' + error.toString());
    return { success: false, error: error.toString() };
  }
}
